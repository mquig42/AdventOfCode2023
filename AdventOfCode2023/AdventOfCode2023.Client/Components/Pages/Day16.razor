@page "/Day16"
@rendermode InteractiveWebAssembly

<PageTitle>Day 16</PageTitle>

@* <style>
    body {
        background-image: url(/media/background15.jpg);
        color: white;
    }
</style> *@

<h2>Day 16</h2>

<div style="display:table-cell">
    <textarea cols="110" rows="25" @bind="puzzleInput" />
    <div align="right"><button @onclick="Run">Run</button></div>
</div>

<hr />
<h3>Part 1:</h3>
<p>@output1</p>

<hr />
<h3>Part 2:</h3>
<p>@output2</p>

<hr />
<h3>Notes</h3>
<p>My first attempt at solving part 1 used a single <code>HashSet</code> to track visited tiles, and traced each beam until it went out of bounds. When I tried it on the sample input, I got an infinite loop. Turns out not every beam goes off the edge of the grid. I had to use 4 <code>HashSet</code>s, one for each direction.</p>

@code
{
    int output1 = 0;
    int output2 = 0;
    string puzzleInput = "";

    string[] grid = [];
    HashSet<int> eRight = new HashSet<int>();
    HashSet<int> eDown = new HashSet<int>();
    HashSet<int> eLeft = new HashSet<int>();
    HashSet<int> eUp = new HashSet<int>();

    const int RIGHT = 1;
    const int DOWN = 1000;
    const int LEFT = -1;
    const int UP = -1000;

    //Integer coordinate system. Position is a single value, row*1000+col. I have defined constants for the directions.

    void Run()
    {
        grid = puzzleInput.Trim().Split('\n');
        eRight.Clear();
        eDown.Clear();
        eLeft.Clear();
        eUp.Clear();

        Beam(0, RIGHT);
        eRight.UnionWith(eDown);
        eRight.UnionWith(eLeft);
        eRight.UnionWith(eUp);
        output1 = eRight.Count;
    }

    void Beam(int pos, int dir)
    {
        //Out of bounds detection
        if (pos < 0 || pos / 1000 >= grid.Length || pos % 1000 >= grid[0].Length)
            return;

        //Have we been in this position and direction before? If so stop. Prevents infinite loops.
        if (dir == RIGHT)
        {
            if (eRight.Contains(pos))
                return;
            eRight.Add(pos);
        }
        else if (dir == DOWN)
        {
            if (eDown.Contains(pos))
                return;
            eDown.Add(pos);
        }
        else if (dir == LEFT)
        {
            if (eLeft.Contains(pos))
                return;
            eLeft.Add(pos);
        }
        else if (dir == UP)
        {
            if (eUp.Contains(pos))
                return;
            eUp.Add(pos);
        }

        //Move to next tile
        switch (grid[pos / 1000][pos % 1000])
        {
            case '\\':
                if (dir == RIGHT)
                    Beam(pos + DOWN, DOWN);
                else if (dir == DOWN)
                    Beam(pos + RIGHT, RIGHT);
                else if (dir == LEFT)
                    Beam(pos + UP, UP);
                else if (dir == UP)
                    Beam(pos + LEFT, LEFT);
                break;
            case '/':
                if (dir == RIGHT)
                    Beam(pos + UP, UP);
                else if (dir == DOWN)
                    Beam(pos + LEFT, LEFT);
                else if (dir == LEFT)
                    Beam(pos + DOWN, DOWN);
                else if (dir == UP)
                    Beam(pos + RIGHT, RIGHT);
                break;
            case '-':
                if (dir == LEFT || dir == RIGHT)
                    Beam(pos + dir, dir);
                else if (dir == DOWN || dir == UP)
                {
                    Beam(pos + LEFT, LEFT);
                    Beam(pos + RIGHT, RIGHT);
                }
                break;
            case '|':
                if (dir == LEFT || dir == RIGHT)
                {
                    Beam(pos + DOWN, DOWN);
                    Beam(pos + UP, UP);
                }
                else if (dir == UP || dir == DOWN)
                    Beam(pos + dir, dir);
                break;
            default:
                Beam(pos + dir, dir);
                break;
        }
    }
}
